/**
 * Multi-agent worktree support for DevPlan.
 *
 * When multiple Claude Code agents work on the same project simultaneously,
 * each agent gets its own git worktree to avoid:
 * - Shared config file conflicts (lockfiles, node_modules, etc.)
 * - Lock file corruption from concurrent writes
 * - Port conflicts for dev servers
 * - Database migration ordering issues
 *
 * Architecture:
 *   project/              ← main worktree (human + verifier)
 *   project-wt/
 *     executor-0/         ← worktree for first parallel executor
 *     executor-1/         ← worktree for second parallel executor
 *     ...
 */

import type { ProjectBrief } from "./models";
import { parseBrief } from "./generators";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface WorktreeConfig {
	/** Maximum parallel executor agents */
	maxParallel: number;
	/** Base directory for worktrees (relative to project root) */
	worktreeDir: string;
	/** Port offset per agent (agent N gets basePort + N*portStride) */
	portStride: number;
	/** Base port for dev servers */
	basePort: number;
	/** Whether to isolate database per worktree */
	isolateDatabase: boolean;
	/** Lock strategy for shared resources */
	lockStrategy: "advisory" | "flock" | "none";
}

export const DEFAULT_WORKTREE_CONFIG: WorktreeConfig = {
	maxParallel: 3,
	worktreeDir: "../${project}-wt",
	portStride: 10,
	basePort: 3000,
	isolateDatabase: true,
	lockStrategy: "advisory",
};

// ---------------------------------------------------------------------------
// Setup script generation
// ---------------------------------------------------------------------------

/**
 * Generate a shell script that sets up git worktrees for parallel agents.
 */
export function generateWorktreeSetupScript(
	briefContent: string,
	config: Partial<WorktreeConfig> = {}
): { content: string; filePath: string } {
	const brief = parseBrief(briefContent);
	const cfg = { ...DEFAULT_WORKTREE_CONFIG, ...config };
	const projectSlug = brief.projectName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
	const wtDir = cfg.worktreeDir.replace("${project}", projectSlug);

	const content = `#!/usr/bin/env bash
# DevPlan Multi-Agent Worktree Setup for ${brief.projectName}
# Generated by DevPlan MCP Server
#
# Usage:
#   ./scripts/setup-worktrees.sh [count]    # Create worktrees (default: ${cfg.maxParallel})
#   ./scripts/setup-worktrees.sh teardown   # Remove all worktrees
#   ./scripts/setup-worktrees.sh status     # Show worktree status
#
# Each worktree gets:
#   - Its own branch (wt/executor-N)
#   - Isolated node_modules / venv / target dir
#   - Unique port assignment (base ${cfg.basePort} + N*${cfg.portStride})
#   - Isolated database (if applicable)

set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "\${BASH_SOURCE[0]}")/.." && pwd)"
PROJECT_NAME="${projectSlug}"
WT_BASE="${wtDir}"
MAX_PARALLEL=${cfg.maxParallel}
BASE_PORT=${cfg.basePort}
PORT_STRIDE=${cfg.portStride}

# Colors
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m'

log()  { echo -e "\${GREEN}[worktree]\${NC} $*"; }
warn() { echo -e "\${YELLOW}[worktree]\${NC} $*"; }
err()  { echo -e "\${RED}[worktree]\${NC} $*" >&2; }

# ── Status ──────────────────────────────────────────────────────────────────
cmd_status() {
    log "Git worktrees:"
    git -C "$PROJECT_ROOT" worktree list
    echo ""
    for i in $(seq 0 $((MAX_PARALLEL - 1))); do
        local wt_path="\${PROJECT_ROOT}/\${WT_BASE}/executor-\${i}"
        if [ -d "$wt_path" ]; then
            local branch
            branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "detached")
            local port=$((BASE_PORT + i * PORT_STRIDE))
            log "  executor-$i: $wt_path (branch: $branch, port: $port)"
        fi
    done
}

# ── Teardown ────────────────────────────────────────────────────────────────
cmd_teardown() {
    warn "Removing all agent worktrees..."
    for i in $(seq 0 $((MAX_PARALLEL - 1))); do
        local wt_path="\${PROJECT_ROOT}/\${WT_BASE}/executor-\${i}"
        local branch="wt/executor-\${i}"
        if [ -d "$wt_path" ]; then
            git -C "$PROJECT_ROOT" worktree remove --force "$wt_path" 2>/dev/null || true
            git -C "$PROJECT_ROOT" branch -D "$branch" 2>/dev/null || true
            log "  Removed executor-$i"
        fi
    done
    rmdir "\${PROJECT_ROOT}/\${WT_BASE}" 2>/dev/null || true
    log "Teardown complete."
}

# ── Setup ───────────────────────────────────────────────────────────────────
cmd_setup() {
    local count=\${1:-$MAX_PARALLEL}
    log "Setting up $count agent worktrees for ${brief.projectName}..."

    mkdir -p "\${PROJECT_ROOT}/\${WT_BASE}"

    for i in $(seq 0 $((count - 1))); do
        local wt_path="\${PROJECT_ROOT}/\${WT_BASE}/executor-\${i}"
        local branch="wt/executor-\${i}"
        local port=$((BASE_PORT + i * PORT_STRIDE))

        if [ -d "$wt_path" ]; then
            warn "  executor-$i already exists, skipping"
            continue
        fi

        # Create branch from main (or current HEAD)
        git -C "$PROJECT_ROOT" branch "$branch" HEAD 2>/dev/null || true
        git -C "$PROJECT_ROOT" worktree add "$wt_path" "$branch"

        # Write agent-local .env with port assignments
        cat > "\${wt_path}/.env.agent" <<AGENTENV
# Auto-generated by DevPlan worktree setup
# Agent: executor-$i
AGENT_ID=executor-$i
AGENT_PORT=$port
AGENT_DB_SUFFIX=_agent_$i
AGENT_WORKTREE=true
AGENTENV
${brief.mustUseTech.some(t => t.toLowerCase().includes("node") || t.toLowerCase().includes("typescript") || t.toLowerCase().includes("javascript")) ? `
        # Install dependencies in worktree (isolated node_modules)
        if [ -f "\${wt_path}/package.json" ]; then
            log "  Installing dependencies for executor-$i..."
            (cd "$wt_path" && npm install --prefer-offline 2>/dev/null) || true
        fi` : ""}${brief.mustUseTech.some(t => t.toLowerCase().includes("python")) ? `
        # Create isolated venv in worktree
        if [ -f "\${wt_path}/pyproject.toml" ] || [ -f "\${wt_path}/setup.py" ]; then
            log "  Creating venv for executor-$i..."
            python3 -m venv "\${wt_path}/.venv" 2>/dev/null || true
            "\${wt_path}/.venv/bin/pip" install -e "\${wt_path}[dev]" 2>/dev/null || true
        fi` : ""}${brief.mustUseTech.some(t => t.toLowerCase().includes("rust")) ? `
        # Rust uses per-worktree target dirs automatically via CARGO_TARGET_DIR
        export CARGO_TARGET_DIR="\${wt_path}/target"` : ""}

        log "  ✅ executor-$i ready (branch: $branch, port: $port)"
    done

    log ""
    log "Worktrees ready. Launch agents with:"
    for i in $(seq 0 $((count - 1))); do
        log "  cd \${WT_BASE}/executor-$i && claude --agent-file .claude/agents/${projectSlug}-executor.md"
    done
}

# ── Lock helpers (for shared resources like databases) ──────────────────────
LOCK_DIR="\${PROJECT_ROOT}/.devplan-locks"

acquire_lock() {
    local resource="\$1"
    local agent="\${AGENT_ID:-unknown}"
    mkdir -p "$LOCK_DIR"
    local lockfile="\${LOCK_DIR}/\${resource}.lock"

    # Advisory lock with timeout
    local attempts=0
    while [ -f "$lockfile" ] && [ $attempts -lt 30 ]; do
        local holder
        holder=$(cat "$lockfile" 2>/dev/null || echo "unknown")
        warn "  Lock on '$resource' held by $holder, waiting... ($attempts/30)"
        sleep 2
        attempts=$((attempts + 1))
    done

    if [ -f "$lockfile" ]; then
        err "  Failed to acquire lock on '$resource' after 60s"
        return 1
    fi

    echo "$agent" > "$lockfile"
    log "  Lock acquired: $resource (by $agent)"
}

release_lock() {
    local resource="\$1"
    rm -f "\${LOCK_DIR}/\${resource}.lock"
    log "  Lock released: $resource"
}

# ── Main ────────────────────────────────────────────────────────────────────
case "\${1:-setup}" in
    teardown) cmd_teardown ;;
    status)   cmd_status ;;
    setup)    cmd_setup "\${2:-$MAX_PARALLEL}" ;;
    *)        cmd_setup "\$1" ;;
esac
`;

	return { content, filePath: "scripts/setup-worktrees.sh" };
}

// ---------------------------------------------------------------------------
// Agent instruction addendum for worktree-aware execution
// ---------------------------------------------------------------------------

/**
 * Generate worktree-specific instructions to append to executor agents.
 * These instructions teach the agent how to work within a worktree context.
 */
export function generateWorktreeAgentInstructions(
	briefContent: string,
	config: Partial<WorktreeConfig> = {}
): string {
	const brief = parseBrief(briefContent);
	const cfg = { ...DEFAULT_WORKTREE_CONFIG, ...config };
	const projectSlug = brief.projectName.toLowerCase().replace(/[^a-z0-9]+/g, "-");

	return `
## Multi-Agent Worktree Mode

> This agent may run in a git worktree alongside other parallel agents.
> Follow these rules to avoid conflicts.

### Environment Detection

On startup, check for worktree mode:
\`\`\`bash
# Check if running in a worktree
if [ -f .env.agent ]; then
    source .env.agent
    echo "Running as $AGENT_ID on port $AGENT_PORT"
fi
\`\`\`

If \`.env.agent\` exists, you are in **worktree mode**. Apply all rules below.

### Port Isolation

**CRITICAL**: Never hardcode ports. Always use the agent's assigned port.

\`\`\`bash
# Read port from .env.agent
source .env.agent
PORT=\${AGENT_PORT:-${cfg.basePort}}
\`\`\`

When starting dev servers, use \`$AGENT_PORT\` instead of the default port.
This prevents "address already in use" when multiple agents run simultaneously.

### Branch Discipline

In worktree mode, each worktree has its own branch (\`wt/executor-N\`).

**Modified git workflow:**
1. Work directly on the worktree branch (don't create sub-branches)
2. Commit normally to the worktree branch
3. When task is complete, the merge happens from the main worktree:
   \`\`\`bash
   # From main worktree (not agent worktree):
   git merge --squash wt/executor-0
   git commit -m "feat: complete task X.Y"
   \`\`\`
4. **DO NOT** merge or rebase from within the worktree

### Shared Resource Locking

For operations that touch shared state (database migrations, shared config):

\`\`\`bash
# Source the lock helpers
source scripts/setup-worktrees.sh

# Before running migrations:
acquire_lock "database-migration"
# ... run migration ...
release_lock "database-migration"
\`\`\`

**Resources that need locking:**
- Database migrations (\`database-migration\`)
- Shared config file writes (\`config-write\`)
- Package registry publishes (\`publish\`)

### Database Isolation

${cfg.isolateDatabase ? `When \`.env.agent\` is present, use an agent-specific database:

\`\`\`bash
source .env.agent
DB_NAME="$PROJECT_NAME\${AGENT_DB_SUFFIX}"  # e.g., ${projectSlug}_agent_0
\`\`\`

This prevents migration ordering conflicts between parallel agents.` : `Database isolation is disabled. Use locking for migration ordering.`}

### Config File Conflicts

**Files that must NOT be modified in worktree mode** (modify in main only):
- \`package-lock.json\` / \`yarn.lock\` / \`pnpm-lock.yaml\`
- \`Cargo.lock\` (only if workspace root)
- \`.env\` (use \`.env.agent\` for agent-specific overrides)
- CI/CD configs (\`.github/workflows/\`)

**Safe to modify in worktrees:**
- Source code files
- Test files
- Documentation
- Agent-specific config (\`.env.agent\`)

### Conflict Resolution

If you detect a conflict with another agent's work:
1. **STOP** — do not force-push or overwrite
2. Check the lock directory: \`ls .devplan-locks/\`
3. Wait for the other agent to complete (check lock files)
4. If stuck >5 minutes, report to user

### Merging Back

When your task is complete:
1. Commit all changes to your worktree branch
2. Push the branch: \`git push origin wt/executor-N\`
3. Report completion — the orchestrator merges from the main worktree
4. **DO NOT** switch branches or merge yourself
`;
}

// ---------------------------------------------------------------------------
// CLAUDE.md addendum for multi-agent coordination
// ---------------------------------------------------------------------------

/**
 * Generate a CLAUDE.md section for multi-agent project coordination.
 * This goes into the main CLAUDE.md to describe the multi-agent setup.
 */
export function generateMultiAgentClaudeMdSection(
	briefContent: string,
	config: Partial<WorktreeConfig> = {}
): string {
	const brief = parseBrief(briefContent);
	const cfg = { ...DEFAULT_WORKTREE_CONFIG, ...config };
	const projectSlug = brief.projectName.toLowerCase().replace(/[^a-z0-9]+/g, "-");

	return `
## Multi-Agent Development (Worktree Mode)

This project supports parallel development using git worktrees.
Multiple Claude Code executor agents can work on different tasks simultaneously.

### Setup

\`\`\`bash
# Create ${cfg.maxParallel} parallel worktrees
./scripts/setup-worktrees.sh ${cfg.maxParallel}

# Check status
./scripts/setup-worktrees.sh status

# Teardown when done
./scripts/setup-worktrees.sh teardown
\`\`\`

### Architecture

\`\`\`
${projectSlug}/                    ← main worktree (human + verifier)
${projectSlug}-wt/
  executor-0/                      ← agent 0 (port ${cfg.basePort})
  executor-1/                      ← agent 1 (port ${cfg.basePort + cfg.portStride})
  executor-2/                      ← agent 2 (port ${cfg.basePort + 2 * cfg.portStride})
\`\`\`

### Launching Parallel Agents

\`\`\`bash
# Terminal 1 — executor 0 works on task 1.1
cd ${projectSlug}-wt/executor-0
claude "execute subtask 1.1.1" --agent-file .claude/agents/${projectSlug}-executor.md

# Terminal 2 — executor 1 works on task 1.2 (if no dependency)
cd ${projectSlug}-wt/executor-1
claude "execute subtask 1.2.1" --agent-file .claude/agents/${projectSlug}-executor.md

# Main worktree — verifier reviews completed work
cd ${projectSlug}
claude "verify task 1.1" --agent-file .claude/agents/${projectSlug}-verifier.md
\`\`\`

### Merge Strategy

1. Each agent works on its worktree branch (\`wt/executor-N\`)
2. When a task completes, merge from the main worktree:
   \`\`\`bash
   cd ${projectSlug}
   git merge --squash wt/executor-0
   git commit -m "feat: complete task X.Y"
   \`\`\`
3. Update other worktrees after merge:
   \`\`\`bash
   cd ${projectSlug}-wt/executor-1
   git rebase main
   \`\`\`

### Edge Cases

| Scenario | Resolution |
|----------|------------|
| Shared config file modified | Lock via \`.devplan-locks/\`, modify from main only |
| Lock file conflicts | Each worktree has isolated deps (node_modules/venv/target) |
| Port conflicts | Each agent reads \`AGENT_PORT\` from \`.env.agent\` |
| DB migration ordering | ${cfg.isolateDatabase ? "Each agent uses isolated DB (suffix \\_agent\\_N)" : "Lock \\'database-migration\\' before migrating"} |
| Two agents edit same file | Task dependency graph prevents this; if forced, lock the file |
`;
}
