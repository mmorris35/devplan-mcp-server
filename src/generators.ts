/**
 * Generators for DevPlan MCP Server.
 * Creates PROJECT_BRIEF.md, DEVELOPMENT_PLAN.md, and claude.md content.
 */

import type { DevelopmentPlan, Phase, ProjectBrief, TechStack } from "./models";
import { getTemplate } from "./templates";

export interface BriefInput {
	name: string;
	projectType: string;
	goal: string;
	targetUsers: string[];
	features: string[];
	techStack?: {
		mustUse?: string[];
		cannotUse?: string[];
	};
	timeline?: string;
	constraints?: string[];
}

export function createBrief(input: BriefInput): string {
	const mustUse = input.techStack?.mustUse?.map((t) => `- ${t}`).join("\n") || "- (none specified)";
	const cannotUse = input.techStack?.cannotUse?.map((t) => `- ${t}`).join("\n") || "- (none specified)";
	const features = input.features.map((f) => `- ${f}`).join("\n");
	const constraints = input.constraints?.map((c) => `- ${c}`).join("\n") || "- (none specified)";

	return `# PROJECT_BRIEF.md

## Basic Information

- **Project Name**: ${input.name}
- **Project Type**: ${input.projectType}
- **Primary Goal**: ${input.goal}
- **Target Users**: ${input.targetUsers.join(", ")}
- **Timeline**: ${input.timeline || "Not specified"}
- **Team Size**: 1

## Functional Requirements

### Key Features (MVP)

${features}

### Nice-to-Have Features (v2)

- (to be determined)

## Technical Constraints

### Must Use

${mustUse}

### Cannot Use

${cannotUse}

## Other Constraints

${constraints}

## Success Criteria

- All MVP features implemented and working
- Code passes linting and type checking
- Test coverage >= 80%
- Documentation complete

---

*Generated by DevPlan MCP Server*
`;
}

export function parseBrief(content: string): ProjectBrief {
	const lines = content.split("\n");

	const extractField = (fieldName: string): string => {
		for (const line of lines) {
			if (line.includes(`**${fieldName}**:`)) {
				const value = line.split(":").slice(1).join(":").trim();
				return value.replace(/\*\*/g, "");
			}
		}
		return "";
	};

	const extractList = (sectionName: string): string[] => {
		const items: string[] = [];
		let inSection = false;

		for (const line of lines) {
			if (line.includes(sectionName)) {
				inSection = true;
				continue;
			}
			if (inSection) {
				if (line.startsWith("##") || line.startsWith("---")) {
					break;
				}
				if (line.startsWith("- ") && !line.includes("(none") && !line.includes("(to be")) {
					items.push(line.substring(2).trim());
				}
			}
		}
		return items;
	};

	return {
		projectName: extractField("Project Name"),
		projectType: extractField("Project Type"),
		primaryGoal: extractField("Primary Goal"),
		targetUsers: extractField("Target Users"),
		timeline: extractField("Timeline"),
		teamSize: extractField("Team Size") || "1",
		keyFeatures: extractList("Key Features"),
		niceToHaveFeatures: extractList("Nice-to-Have"),
		mustUseTech: extractList("Must Use"),
		cannotUseTech: extractList("Cannot Use"),
		successCriteria: extractList("Success Criteria"),
		performanceRequirements: {},
		securityRequirements: {},
		scalabilityRequirements: {},
		availabilityRequirements: {},
		existingKnowledge: [],
		infrastructureAccess: [],
		externalSystems: [],
		dataSources: [],
		dataDestinations: [],
		knownChallenges: [],
		referenceMaterials: [],
		questionsAndClarifications: [],
		useCases: [],
		deliverables: [],
	};
}

export function generateTechStack(brief: ProjectBrief): TechStack {
	const template = getTemplate(brief.projectType);
	const defaults = template.defaultTechStack;

	const cannotUse = brief.cannotUseTech.map((t) => t.toLowerCase());

	const isBlocked = (tech: string | undefined): boolean => {
		if (!tech) return false;
		return cannotUse.some((blocked) => tech.toLowerCase().includes(blocked));
	};

	// Build tech stack respecting constraints
	let language = defaults.language;
	let framework = defaults.framework || "";
	let database = defaults.database || "";
	const testing = defaults.testing || "pytest";
	const linting = defaults.linting || "ruff";
	const typeChecking = defaults.typeChecking || "mypy";
	let deployment = defaults.deployment || "";
	const ciCd = defaults.ciCd || "GitHub Actions";

	if (isBlocked(language)) language = "Python 3.11+";
	if (isBlocked(framework)) framework = "";
	if (isBlocked(database)) database = "";
	if (isBlocked(deployment)) deployment = "";

	// Add must_use items to additional tools
	const additionalTools: Record<string, string> = {};
	brief.mustUseTech.forEach((tech, i) => {
		additionalTools[`must_use_${i}`] = tech;
	});

	return {
		language,
		framework,
		database,
		testing,
		linting,
		typeChecking,
		deployment,
		ciCd,
		additionalTools,
	};
}

export function generatePhases(brief: ProjectBrief): Phase[] {
	const template = getTemplate(brief.projectType);
	const phaseNames = template.defaultPhases;

	return phaseNames.map((name, i) => ({
		id: String(i),
		title: name,
		goal: `Complete ${name.toLowerCase()} phase`,
		days: "",
		description: "",
		tasks: [],
	}));
}

export function generatePlan(briefContent: string): string {
	const brief = parseBrief(briefContent);
	const techStack = generateTechStack(brief);
	const phases = generatePhases(brief);

	const techStackSection = Object.entries(techStack)
		.filter(([key, value]) => value && key !== "additionalTools")
		.map(([key, value]) => `- **${formatKey(key)}**: ${value}`)
		.join("\n");

	const phasesSection = phases
		.map(
			(phase) => `### Phase ${phase.id}: ${phase.title}

**Goal**: ${phase.goal}

**Tasks**: (to be defined by Claude Code based on project requirements)

---`
		)
		.join("\n\n");

	return `# DEVELOPMENT_PLAN.md

## Project: ${brief.projectName}

## Technology Stack

${techStackSection}

## Development Phases

${phasesSection}

## Git Workflow

- **Branching Strategy**: One branch per task (e.g., \`feature/1-2-user-auth\`)
- **Commit Convention**: Semantic commits (feat:, fix:, refactor:, etc.)
- **Merge Strategy**: Squash merge when task is complete
- **PR Required**: Yes for production branches

## Progress Tracking

Use subtask IDs (X.Y.Z format) for tracking:
- Mark subtasks complete when all deliverables are done
- Add completion notes for context
- Update status: pending → in_progress → completed

---

*Generated by DevPlan MCP Server*
`;
}

export function generateClaudeMd(
	briefContent: string,
	language: string = "python",
	testCoverage: number = 80
): string {
	const brief = parseBrief(briefContent);

	return `# claude.md - Project Rules for ${brief.projectName}

## Project Overview

**Type**: ${brief.projectType}
**Goal**: ${brief.primaryGoal}
**Language**: ${language}

## Code Standards

### Style
- Follow ${language === "python" ? "PEP 8" : "ESLint"} conventions
- Use ${language === "python" ? "ruff" : "prettier"} for formatting
- Maximum line length: 100 characters

### Type Safety
- ${language === "python" ? "Use type hints on all functions" : "Use TypeScript strict mode"}
- No \`any\` types without explicit justification
- Document complex types with comments

### Testing
- Minimum test coverage: ${testCoverage}%
- Write tests before implementation (TDD encouraged)
- Use descriptive test names: \`test_<function>_<scenario>_<expected>\`

### Documentation
- All public functions must have docstrings
- Include usage examples in docstrings
- Keep README.md up to date

## Git Workflow

### Branching
- Branch from \`main\` for each task
- Format: \`feature/<phase>-<task>-<description>\`
- Example: \`feature/1-2-user-authentication\`

### Commits
- Use semantic commit messages
- Format: \`<type>: <description>\`
- Types: feat, fix, refactor, test, docs, chore

### Pull Requests
- Squash merge to main
- Include task ID in PR title
- Ensure CI passes before merge

## Quality Gates

Before marking a task complete:
1. All tests pass
2. Linting passes with no warnings
3. Type checking passes
4. Code reviewed (self-review acceptable for solo dev)
5. Documentation updated if needed

---

*Generated by DevPlan MCP Server*
`;
}

function formatKey(key: string): string {
	return key
		.replace(/([A-Z])/g, " $1")
		.replace(/^./, (str) => str.toUpperCase())
		.trim();
}

export function validatePlan(content: string, strict: boolean = false): {
	valid: boolean;
	errors: string[];
	warnings: string[];
	suggestions: string[];
} {
	const errors: string[] = [];
	const warnings: string[] = [];
	const suggestions: string[] = [];

	// Check for required sections
	if (!content.includes("# DEVELOPMENT_PLAN")) {
		errors.push("Missing DEVELOPMENT_PLAN header");
	}

	if (!content.includes("## Technology Stack")) {
		errors.push("Missing Technology Stack section");
	}

	if (!content.includes("## Development Phases")) {
		errors.push("Missing Development Phases section");
	}

	// Check for phases
	const phaseMatches = content.match(/### Phase \d+:/g);
	if (!phaseMatches || phaseMatches.length === 0) {
		errors.push("No phases defined in the plan");
	} else if (phaseMatches.length < 3) {
		warnings.push(`Only ${phaseMatches.length} phases defined, consider adding more structure`);
	}

	// Check for Phase 0 Foundation
	if (!content.includes("Phase 0: Foundation")) {
		warnings.push("Phase 0 should be titled 'Foundation'");
	}

	// Suggestions
	if (!content.includes("Git Workflow")) {
		suggestions.push("Consider adding a Git Workflow section");
	}

	if (!content.includes("Progress Tracking")) {
		suggestions.push("Consider adding a Progress Tracking section");
	}

	const valid = strict ? errors.length === 0 && warnings.length === 0 : errors.length === 0;

	return { valid, errors, warnings, suggestions };
}

export function getSubtask(
	planContent: string,
	subtaskId: string
): { found: boolean; subtask?: { id: string; title: string; phase: string; task: string } } {
	// Simple parser - looks for subtask pattern X.Y.Z
	const regex = new RegExp(`(\\d+)\\.(\\d+)\\.${subtaskId.split(".")[2]}[:\\s]+(.+)`, "g");
	const match = regex.exec(planContent);

	if (match) {
		return {
			found: true,
			subtask: {
				id: subtaskId,
				title: match[3]?.trim() || "Unknown",
				phase: match[1] || "0",
				task: `${match[1]}.${match[2]}`,
			},
		};
	}

	return { found: false };
}

export function updateProgress(
	planContent: string,
	subtaskId: string,
	completionNotes: string
): string {
	// Add completion marker to subtask
	const timestamp = new Date().toISOString().split("T")[0];
	const marker = `[COMPLETED ${timestamp}] ${completionNotes}`;

	// Find and update the subtask line
	const lines = planContent.split("\n");
	const updatedLines = lines.map((line) => {
		if (line.includes(subtaskId) && !line.includes("[COMPLETED")) {
			return `${line} ${marker}`;
		}
		return line;
	});

	return updatedLines.join("\n");
}
